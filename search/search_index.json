{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MOCluGen","text":"<p>MOCluGen is a MATLAB/Octave package for generating multidimensional clusters using the CluGen algorithm. It provides the <code>clugen()</code> function for this purpose, as well as a number of auxiliary functions, used internally and modularly by <code>clugen()</code>. Users can swap these auxiliary functions by their own customized versions, fine-tuning their cluster generation strategies, or even use them as the basis for their own generation algorithms.</p>"},{"location":"#how-to-install","title":"How to install","text":"<p>Download the package from its GitHub page or clone it with following command in the terminal:</p> <pre><code>$ git clone https://github.com/clugen/MOCluGen.git\n</code></pre> <p>Open MATLAB or GNU Octave and <code>cd</code> into the project's folder, and run the <code>startup.m</code> script:</p> <pre><code>startup\n</code></pre> <p>MOCluGen is now ready to use.</p>"},{"location":"#quick-start","title":"Quick start","text":"<pre><code>o = clugen(2, 4, 400, [1 0], pi / 8, [50, 10], 20, 1, 2, 'seed', 123);\nscatter(o.points(:, 1), o.points(:, 2), 36, o.clusters, 'filled', 'MarkerEdgeColor', 'k');\n</code></pre> <pre><code>o = clugen(3, 4, 1000, [1 0 0], pi / 8, [20 15 25], 16, 4, 3.5, 'seed', 123);\nscatter3(o.points(:, 1), o.points(:, 2), o.points(:,3), 36, o.clusters, 'filled', 'MarkerEdgeColor', 'k');\n</code></pre>"},{"location":"#further-reading","title":"Further reading","text":"<ul> <li>Theory: the clugen algorithm in detail</li> <li>Examples</li> <li>Reference</li> <li>Developing this package</li> </ul>"},{"location":"dev/","title":"Development","text":""},{"location":"dev/#clone-and-install","title":"Clone and install","text":"<p>Clone the project with following command in the terminal:</p> <pre><code>$ git clone https://github.com/clugen/MOCluGen.git\n</code></pre> <p>Alternatively, download the package from its GitHub page.</p> <p>Open MATLAB or GNU Octave and <code>cd</code> into the project's folder, and run the <code>startup.m</code> script:</p> <pre><code>startup\n</code></pre> <p><code>MOCluGen</code> can now be used and/or developed.</p>"},{"location":"dev/#run-tests","title":"Run tests","text":"<p>Tests require the MOxUnit testing framework. Download it, open MATLAB or GNU Octave, <code>cd</code> into framework's folder, and run the following instruction:</p> <pre><code>moxunit_set_path()\n</code></pre> <p>In MATLAB/Octave change to the <code>MOCluGen</code> folder, and execute the following instructions to run the tests:</p> <pre><code>startup\nmoxunit_runtests tests\n</code></pre>"},{"location":"dev/#build-docs","title":"Build docs","text":"<p>Building the documentation requires Octave, Python and mkdocs-material and must be performed on a Bash shell. A physical or virtual display (e.g., xvfb) are required for generating good looking plots. After these requirements are met, and considering we're in the <code>MOCluGen</code> folder, run the following commands:</p> <pre><code>$ cd docs\n$ python mocdoc.py                    # Get doc-comments from MATLAB source files\n$ ./run_moc_in_md.sh docs/examples.md # Run examples code and generate images\n$ mkdocs build                        # Build docs\n</code></pre> <p>The documentation can be served locally with:</p> <pre><code>$ mkdocs serve\n</code></pre>"},{"location":"dev/#code-style","title":"Code style","text":"<p>To contribute to MOCluGen, follow this code style:</p> <ul> <li>Encoding: UTF-8</li> <li>Indentation: 4 spaces (no tabs)</li> <li>Line size limit: 100 chars</li> <li>Newlines: Unix style, i.e. LF or <code>\\n</code></li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>These examples can be exactly reproduced in GNU Octave 5.2.0 by using the seed specified at the beginning of each code block.</p>"},{"location":"examples/#examples-in-2d","title":"Examples in 2D","text":"<p>These examples were plotted with the <code>plot_examples_2d()</code> helper function available here.</p>"},{"location":"examples/#manipulating-the-direction-of-cluster-supporting-lines","title":"Manipulating the direction of cluster-supporting lines","text":""},{"location":"examples/#using-the-direction-parameter","title":"Using the <code>direction</code> parameter","text":"<pre><code>seed = 123;\ne01 = clugen(2, 4, 200, [1 0], 0, [10 10], 10, 1.5, 0.5, 'seed', seed);\ne02 = clugen(2, 4, 200, [1 1], 0, [10 10], 10, 1.5, 0.5, 'seed', seed);\ne03 = clugen(2, 4, 200, [0 1], 0, [10 10], 10, 1.5, 0.5, 'seed', seed);\n</code></pre> <pre><code>plot_examples_2d(...\ne01, 'e01: direction = [1; 0]', ...\ne02, 'e02: direction = [1; 1]', ...\ne03, 'e03: direction = [0; 1]');\n</code></pre>"},{"location":"examples/#changing-the-angle_disp-parameter-and-using-a-custom-angle_deltas_fn-function","title":"Changing the <code>angle_disp</code> parameter and using a custom <code>angle_deltas_fn</code> function","text":"<pre><code>seed = 9876;\n% Custom angle_deltas function: arbitrarily rotate some clusters by 90 degrees\n% Requires the statistics toolbox in either Octave or MATLAB\nangdel_90 = @(nclu, astd) randsample([0 pi/2], nclu, true);\ne04 = clugen(2, 6, 500, [1 0], 0, [10 10], 10, 1.5, 0.5, 'seed', seed);\ne05 = clugen(2, 6, 500, [1 0], pi / 8, [10 10], 10, 1.5, 0.5, 'seed', seed);\ne06 = clugen(2, 6, 500, [1 0], 0, [10 10], 10, 1.5, 0.5, 'seed', seed, ...\n'angle_deltas_fn', angdel_90);\n</code></pre> <pre><code>plot_examples_2d(...\ne04, 'e04: angle\\_disp = 0', ...\ne05, 'e05: angle\\_disp = \u03c0/8', ...\ne06, 'e06: custom angle\\_deltas function');\n</code></pre>"},{"location":"examples/#manipulating-the-length-of-cluster-supporting-lines","title":"Manipulating the length of cluster-supporting lines","text":""},{"location":"examples/#using-the-llength-parameter","title":"Using the <code>llength</code> parameter","text":"<pre><code>seed = 1234;\ne07 = clugen(2, 5, 800, [1 0], pi / 10, [10 10], 0, 0, 0.5, 'seed', seed, ...\n'point_dist_fn', 'n');\ne08 = clugen(2, 5, 800, [1 0], pi / 10, [10 10], 10, 0, 0.5, 'seed', seed, ...\n'point_dist_fn', 'n');\ne09 = clugen(2, 5, 800, [1 0], pi / 10, [10 10], 30, 0, 0.5, 'seed', seed, ...\n'point_dist_fn', 'n');\n</code></pre> <pre><code>plot_examples_2d(...\ne07, 'e07: llength = 0', e08, 'e08: llength = 10', e09, 'e09: llength = 30');\n</code></pre>"},{"location":"examples/#changing-the-llength_disp-parameter-and-using-a-custom-llengths_fn-function","title":"Changing the <code>llength_disp</code> parameter and using a custom <code>llengths_fn</code> function","text":"<pre><code>seed = 1234;\n% Custom llengths function: line lengths grow for each new cluster\nllen_grow = @(nclu, llen, llenstd) llen * (0:(nclu - 1))' + llenstd * randn(nclu, 1);\ne10 = clugen(2, 5, 800, [1 0], pi / 10, [10 10], 15,  0.0, 0.5, 'seed', seed, ...\n'point_dist_fn', 'n');\ne11 = clugen(2, 5, 800, [1 0], pi / 10, [10 10], 15, 10.0, 0.5, 'seed', seed, ...\n'point_dist_fn', 'n');\ne12 = clugen(2, 5, 800, [1 0], pi / 10, [10 10], 10,  0.1, 0.5, 'seed', seed, ...\n'point_dist_fn', 'n', 'llengths_fn', llen_grow);\n</code></pre> <pre><code>plot_examples_2d(...\ne10, 'e10: llength\\_disp = 0.0', ...\ne11, 'e11: llength\\_disp = 5.0', ...\ne12, 'e12: custom llengths function');\n</code></pre>"},{"location":"examples/#manipulating-relative-cluster-positions","title":"Manipulating relative cluster positions","text":""},{"location":"examples/#using-the-cluster_sep-parameter","title":"Using the <code>cluster_sep</code> parameter","text":"<pre><code>seed = 3210;\ne13 = clugen(2, 8, 1000, [1 1], pi / 4, [10 10], 10, 2, 2.5, 'seed', seed);\ne14 = clugen(2, 8, 1000, [1 1], pi / 4, [30 10], 10, 2, 2.5, 'seed', seed);\ne15 = clugen(2, 8, 1000, [1 1], pi / 4, [10 30], 10, 2, 2.5, 'seed', seed);\n</code></pre> <pre><code>plot_examples_2d(...\ne13, 'e13: cluster\\_sep = [10; 10]', ...\ne14, 'e14: cluster\\_sep = [30; 10]', ...\ne15, 'e15: cluster\\_sep = [10; 30]');\n</code></pre>"},{"location":"examples/#changing-the-cluster_offset-parameter-and-using-a-custom-clucenters_fn-function","title":"Changing the <code>cluster_offset</code> parameter and using a custom <code>clucenters_fn</code> function","text":"<pre><code>seed = 3210;\n% Custom clucenters function: places clusters in a diagonal\ncenters_diag = @(nclu, csep, coff) ones(nclu, numel(csep)) .* (1:nclu)' * max(csep) + coff';\ne16 = clugen(2, 8, 1000, [1 1], pi / 4, [10 10], 10, 2, 2.5, 'seed', seed);\ne17 = clugen(2, 8, 1000, [1 1], pi / 4, [10 10], 10, 2, 2.5, 'seed', seed, ...\n'cluster_offset', [20 -20]);\ne18 = clugen(2, 8, 1000, [1; 1], pi / 4, [10 10], 10, 2, 2.5, 'seed', seed, ...\n'cluster_offset', [-50 -50], 'clucenters_fn', centers_diag);\n</code></pre> <pre><code>plot_examples_2d(...\ne16, 'e16: default', ...\ne17, 'e17: cluster\\_offset = [20; -20]', ...\ne18, 'e18: custom clucenters function');\n</code></pre>"},{"location":"examples/#lateral-dispersion-and-placement-of-point-projections-on-the-line","title":"Lateral dispersion and placement of point projections on the line","text":""},{"location":"examples/#normal-projection-placement-default-proj_dist_fn-norm","title":"Normal projection placement (default): <code>proj_dist_fn = 'norm'</code>","text":"<pre><code>seed = 5678;\ne19 = clugen(2, 4, 1000, [1 0], pi / 2, [20 20], 13, 2, 0.0, 'seed', seed);\ne20 = clugen(2, 4, 1000, [1 0], pi / 2, [20 20], 13, 2, 1.0, 'seed', seed);\ne21 = clugen(2, 4, 1000, [1 0], pi / 2, [20 20], 13, 2, 3.0, 'seed', seed);\n</code></pre> <pre><code>plot_examples_2d(...\ne19, 'e19: lateral\\_disp = 0', ...\ne20, 'e20: lateral\\_disp = 1', ...\ne21, 'e21: lateral\\_disp = 3');\n</code></pre>"},{"location":"examples/#uniform-projection-placement-proj_dist_fn-unif","title":"Uniform projection placement: <code>proj_dist_fn = 'unif'</code>","text":"<pre><code>seed = 5678;\ne22 = clugen(2, 4, 1000, [1 0], pi / 2, [20 20], 13, 2, 0.0, 'seed', seed, 'proj_dist_fn', 'unif');\ne23 = clugen(2, 4, 1000, [1 0], pi / 2, [20 20], 13, 2, 1.0, 'seed', seed, 'proj_dist_fn', 'unif');\ne24 = clugen(2, 4, 1000, [1 0], pi / 2, [20 20], 13, 2, 3.0, 'seed', seed, 'proj_dist_fn', 'unif');\n</code></pre> <pre><code>plot_examples_2d(...\ne22, 'e22: lateral\\_disp = 0', ...\ne23, 'e23: lateral\\_disp = 1', ...\ne24, 'e24: lateral\\_disp = 3');\n</code></pre>"},{"location":"examples/#custom-projection-placement-using-the-beta-distribution","title":"Custom projection placement using the Beta distribution","text":"<pre><code>seed = 5678;\n% Custom proj_dist_fn: point projections placed using the Beta distribution\n% (requires MATLAB or Octave statistics toolbox)\nproj_beta = @(len, n) len * betarnd(0.1, 0.1, [n 1]) - len / 2;\ne25 = clugen(2, 4, 1000, [1 0], pi / 2, [20 20], 13, 2, 0.0, 'seed', seed, ...\n'proj_dist_fn', proj_beta);\ne26 = clugen(2, 4, 1000, [1 0], pi / 2, [20 20], 13, 2, 1.0, 'seed', seed, ...\n'proj_dist_fn', proj_beta);\ne27 = clugen(2, 4, 1000, [1 0], pi / 2, [20 20], 13, 2, 3.0, 'seed', seed, ...\n'proj_dist_fn', proj_beta);\n</code></pre> <pre><code>plot_examples_2d(...\ne25, 'e25: lateral\\_disp = 0', ...\ne26, 'e26: lateral\\_disp = 1', ...\ne27, 'e27: lateral\\_disp = 3');\n</code></pre>"},{"location":"examples/#controlling-final-point-positions-from-their-projections-on-the-cluster-supporting-line","title":"Controlling final point positions from their projections on the cluster-supporting line","text":""},{"location":"examples/#points-on-hyperplane-orthogonal-to-cluster-supporting-line-default-point_dist_fn-n-1","title":"Points on hyperplane orthogonal to cluster-supporting line (default): <code>point_dist_fn = 'n-1'</code>","text":"<pre><code>seed = 5050;\n% Custom proj_dist_fn: point projections placed using the Beta distribution\n% (requires MATLAB or Octave statistics toolbox)\nproj_beta = @(len, n) len * betarnd(0.03, 0.03, [n 1]) - len / 2;\ne28 = clugen(2, 5, 1500, [1 0], pi / 3, [20 20], 12, 3, 2.0, 'seed', seed);\ne29 = clugen(2, 5, 1500, [1 0], pi / 3, [20 20], 12, 3, 2.0, 'seed', seed, ...\n'proj_dist_fn', 'unif');\ne30 = clugen(2, 5, 1500, [1 0], pi / 3, [20 20], 12, 3, 2.0, 'seed', seed, ...\n'proj_dist_fn', proj_beta);\n</code></pre> <pre><code>plot_examples_2d(...\ne28, 'e28: proj\\_dist\\_fn = \"norm\" (default)', ...\ne29, 'e29: proj\\_dist\\_fn = \"unif\"', ...\ne30, 'e30: custom proj\\_dist\\_fn (Beta)');\n</code></pre>"},{"location":"examples/#points-around-projection-on-cluster-supporting-line-point_dist_fn-n","title":"Points around projection on cluster-supporting line: <code>point_dist_fn = 'n'</code>","text":"<pre><code>seed = 5050;\n% Custom proj_dist_fn: point projections placed using the Beta distribution\n% (requires MATLAB or Octave statistics toolbox)\nproj_beta = @(len, n) len * betarnd(0.03, 0.03, [n 1]) - len / 2;\ne31 = clugen(2, 5, 1500, [1 0], pi / 3, [20 20], 12, 3, 2.0, 'seed', seed, ...\n'point_dist_fn', 'n');\ne32 = clugen(2, 5, 1500, [1 0], pi / 3, [20 20], 12, 3, 2.0, 'seed', seed, ...\n'point_dist_fn', 'n', 'proj_dist_fn', 'unif');\ne33 = clugen(2, 5, 1500, [1 0], pi / 3, [20 20], 12, 3, 2.0, 'seed', seed, ...\n'point_dist_fn', 'n', 'proj_dist_fn', proj_beta);\n</code></pre> <pre><code>plot_examples_2d(...\ne31, 'e31: proj\\_dist\\_fn = \"norm\" (default)', ...\ne32, 'e32: proj\\_dist\\_fn = \"unif\"', ...\ne33, 'e33: custom proj\\_dist\\_fn (Beta)');\n</code></pre>"},{"location":"examples/#custom-point-placement-using-the-exponential-distribution","title":"Custom point placement using the exponential distribution","text":"<pre><code>seed = 5050;\n% Custom point_dist_fn: final points placed using the Exponential distribution\n% (requires MATLAB or Octave statistics toolbox)\nclupoints_n_1_exp = @(projs, lat_std, len, clu_dir, clu_ctr) ...\nclupoints_n_1_template(projs, lat_std, clu_dir, ...\n@(npts, lstd) lstd * exprnd(2 / lstd, [npts 1]));\n% Custom proj_dist_fn: point projections placed using the Beta distribution\n% (requires MATLAB or Octave statistics toolbox)\nproj_beta = @(len, n) len * betarnd(0.03, 0.03, [n 1]) - len / 2;\ne34 = clugen(2, 5, 1500, [1 0], pi / 3, [20 20], 12, 3, 3.0, 'seed', seed, ...\n'point_dist_fn', clupoints_n_1_exp);\ne35 = clugen(2, 5, 1500, [1 0], pi / 3, [20 20], 12, 3, 3.0, 'seed', seed, ...\n'point_dist_fn', clupoints_n_1_exp, 'proj_dist_fn', 'unif');\ne36 = clugen(2, 5, 1500, [1 0], pi / 3, [20 20], 12, 3, 3.0, 'seed', seed, ...\n'point_dist_fn', clupoints_n_1_exp, 'proj_dist_fn', proj_beta);\n</code></pre> <pre><code>plot_examples_2d(...\ne34, 'e34: proj\\_dist\\_fn = \"norm\" (default)', ...\ne35, 'e35: proj\\_dist\\_fn = \"unif\"', ...\ne36, 'e36: custom proj\\_dist\\_fn (Beta)');\n</code></pre>"},{"location":"examples/#manipulating-cluster-sizes","title":"Manipulating cluster sizes","text":"<pre><code>seed = 543210;\n% Custom clusizes_fn (e38): cluster sizes determined via the uniform distribution,\n% no correction for total points\nclusizes_unif = @(nclu, npts, ae) randi(2 * npts / nclu, nclu, 1);\n% Custom clusizes_fn (e39): clusters all have the same size, no correction for\n% total points\nclusizes_equal = @(nclu, npts, ae) floor(npts / nclu) * ones(nclu, 1);\n% Custom clucenters_fn (all): yields fixed positions for the clusters\ncenters_fixed = @(nclu, csep, coff) ...\n[-csep(1) -csep(2); csep(1) -csep(2); -csep(1) csep(2); csep(1) csep(2)];\ne37 = clugen(2, 4, 1500, [1 1], pi, [20 20], 0, 0, 5, 'seed', seed, ...\n'clucenters_fn', centers_fixed, 'point_dist_fn', 'n');\ne38 = clugen(2, 4, 1500, [1 1], pi, [20 20], 0, 0, 5, 'seed', seed, ...\n'clucenters_fn', centers_fixed, 'clusizes_fn', clusizes_unif, 'point_dist_fn', 'n');\ne39 = clugen(2, 4, 1500, [1 1], pi, [20 20], 0, 0, 5, 'seed', seed, ...\n'clucenters_fn', centers_fixed, 'clusizes_fn', clusizes_equal, 'point_dist_fn', 'n');\n</code></pre> <pre><code>plot_examples_2d(...\ne37, 'e37: normal dist. (default)', ...\ne38, 'e38: unif. dist. (custom)', ...\ne39, 'e39: equal size (custom)');\n</code></pre>"},{"location":"examples/#examples-in-3d","title":"Examples in 3D","text":"<p>These examples were plotted with the <code>plot_examples_3d()</code> helper function available here.</p>"},{"location":"examples/#manipulating-the-direction-of-cluster-supporting-lines_1","title":"Manipulating the direction of cluster-supporting lines","text":""},{"location":"examples/#using-the-direction-parameter_1","title":"Using the <code>direction</code> parameter","text":"<pre><code>seed = 1;\ne40 = clugen(3, 4, 500, [1 0 0], 0, [10 10 10], 15, 1.5, 0.5, 'seed', seed);\ne41 = clugen(3, 4, 500, [1 1 1], 0, [10 10 10], 15, 1.5, 0.5, 'seed', seed);\ne42 = clugen(3, 4, 500, [0 0 1], 0, [10 10 10], 15, 1.5, 0.5, 'seed', seed);\n</code></pre> <pre><code>plot_examples_3d(...\ne40, 'e40: direction = [1, 0, 0]', ...\ne41, 'e41: direction = [1, 1, 1]', ...\ne42, 'e42: direction = [0, 0, 1]');\n</code></pre>"},{"location":"examples/#changing-the-angle_disp-parameter-and-using-a-custom-angle_deltas_fn-function_1","title":"Changing the <code>angle_disp</code> parameter and using a custom <code>angle_deltas_fn</code> function","text":"<pre><code>seed = 9876;\n% Custom angle_deltas function: arbitrarily rotate some clusters by 90 degrees\n% Requires the statistics toolbox in either Octave or MATLAB\nangdel_90 = @(nclu, astd) randsample([0 pi/2], nclu, true);\ne43 = clugen(3, 6, 1000, [1 0 0], 0, [10 10 10], 15, 1.5, 0.5, 'seed', seed);\ne44 = clugen(3, 6, 1000, [1 0 0], pi / 8, [10 10 10], 15, 1.5, 0.5, 'seed', seed);\ne45 = clugen(3, 6, 1000, [1 0 0], 0, [10 10 10], 15, 1.5, 0.5, 'seed', seed, 'angle_deltas_fn', angdel_90);\n</code></pre> <pre><code>plot_examples_3d(...\ne43, 'e43: angle\\_disp = 0', ...\ne44, 'e44: angle\\_disp = \u03c0 / 8', ...\ne45, 'e45: custom angle\\_deltas function');\n</code></pre>"},{"location":"examples/#manipulating-the-length-of-cluster-supporting-lines_1","title":"Manipulating the length of cluster-supporting lines","text":""},{"location":"examples/#using-the-llength-parameter_1","title":"Using the <code>llength</code> parameter","text":"<pre><code>seed = 2;\ne46 = clugen(3, 5, 800, [1 0 0], pi / 10, [10 10 10], 0, 0, 0.5, 'seed', seed, 'point_dist_fn', 'n');\ne47 = clugen(3, 5, 800, [1 0 0], pi / 10, [10 10 10], 10, 0, 0.5, 'seed', seed, 'point_dist_fn', 'n');\ne48 = clugen(3, 5, 800, [1 0 0], pi / 10, [10 10 10], 30, 0, 0.5, 'seed', seed, 'point_dist_fn', 'n');\n</code></pre> <pre><code>plot_examples_3d(...\ne46, 'e46: llength = 0', ...\ne47, 'e47: llength = 10', ...\ne48, 'e48: llength = 30');\n</code></pre>"},{"location":"examples/#changing-the-llength_disp-parameter-and-using-a-custom-llengths_fn-function_1","title":"Changing the <code>llength_disp</code> parameter and using a custom <code>llengths_fn</code> function","text":"<pre><code>seed = 2;\n% Custom llengths function: line lengths tend to grow for each new cluster\nllen_grow = @(nclu, llen, llenstd) llen * (0:(nclu - 1))' + llenstd * randn(nclu, 1);\ne49 = clugen(3, 5, 800, [1 0 0], pi / 10, [10 10 10], 15,  0.0, 0.5, 'seed', seed, ...\n'point_dist_fn', 'n');\ne50 = clugen(3, 5, 800, [1 0 0], pi / 10, [10 10 10], 15, 10.0, 0.5, 'seed', seed, ...\n'point_dist_fn', 'n');\ne51 = clugen(3, 5, 800, [1 0 0], pi / 10, [10 10 10], 10,  0.1, 0.5, 'seed', seed, ...\n'llengths_fn', llen_grow, 'point_dist_fn', 'n');\n</code></pre> <pre><code>plot_examples_3d(...\ne49, 'e49: llength\\_disp = 0.0', ...\ne50, 'e50: llength\\_disp = 10.0', ...\ne51, 'e51: custom llengths function');\n</code></pre>"},{"location":"examples/#manipulating-relative-cluster-positions_1","title":"Manipulating relative cluster positions","text":""},{"location":"examples/#using-the-cluster_sep-parameter_1","title":"Using the <code>cluster_sep</code> parameter","text":"<pre><code>seed = 321;\ne52 = clugen(3, 8, 1000, [1 1 1], pi / 4, [30 10 10], 25, 4, 3, 'seed', seed);\ne53 = clugen(3, 8, 1000, [1 1 1], pi / 4, [10 30 10], 25, 4, 3, 'seed', seed);\ne54 = clugen(3, 8, 1000, [1 1 1], pi / 4, [10 10 30], 25, 4, 3, 'seed', seed);\n</code></pre> <pre><code>plot_examples_3d(...\ne52, 'e52: cluster\\_sep = [30, 10, 10]', ...\ne53, 'e53: cluster\\_sep = [10, 30, 10]', ...\ne54, 'e54: cluster\\_sep = [10, 10, 30]');\n</code></pre>"},{"location":"examples/#changing-the-cluster_offset-parameter-and-using-a-custom-clucenters_fn-function_1","title":"Changing the <code>cluster_offset</code> parameter and using a custom <code>clucenters_fn</code> function","text":"<pre><code>seed = 321;\n% Custom clucenters function: places clusters in a diagonal\ncenters_diag = @(nclu, csep, coff) ones(nclu, numel(csep)) .* (1:nclu)' * max(csep) + coff';\ne55 = clugen(3, 8, 1000, [1 1 1], pi / 4, [10 10 10], 12, 3, 2.5, 'seed', seed);\ne56 = clugen(3, 8, 1000, [1 1 1], pi / 4, [10 10 10], 12, 3, 2.5, 'seed', seed, ...\n'cluster_offset', [20 -20 20]);\ne57 = clugen(3, 8, 1000, [1, 1, 1], pi / 4, [10, 10, 10], 12, 3, 2.5, 'seed', seed, ...\n'cluster_offset',  [-50 -50 -50], 'clucenters_fn', centers_diag);\n</code></pre> <pre><code>plot_examples_3d(...\ne55, 'e55: default', ...\ne56, 'e56: cluster\\_offset = [20, -20, 20]', ...\ne57, 'e57: custom clucenters function');\n</code></pre>"},{"location":"examples/#lateral-dispersion-and-placement-of-point-projections-on-the-line_1","title":"Lateral dispersion and placement of point projections on the line","text":""},{"location":"examples/#normal-projection-placement-default-proj_dist_fn-norm_1","title":"Normal projection placement (default): <code>proj_dist_fn = 'norm'</code>","text":"<pre><code>seed = 456;\ne58 = clugen(3, 4, 1000, [1 0 0], pi / 2, [20 20 20], 13, 2, 0.0, 'seed', seed);\ne59 = clugen(3, 4, 1000, [1 0 0], pi / 2, [20 20 20], 13, 2, 1.0, 'seed', seed);\ne60 = clugen(3, 4, 1000, [1 0 0], pi / 2, [20 20 20], 13, 2, 3.0, 'seed', seed);\n</code></pre> <pre><code>plot_examples_3d(...\ne58, 'e58: lateral\\_disp = 0', ...\ne59, 'e59: lateral\\_disp = 1', ...\ne60, 'e60: lateral\\_disp = 3');\n</code></pre>"},{"location":"examples/#uniform-projection-placement-proj_dist_fn-unif_1","title":"Uniform projection placement: <code>proj_dist_fn = 'unif'</code>","text":"<pre><code>seed = 456;\ne61 = clugen(3, 4, 1000, [1 0 0], pi / 2, [20 20 20], 13, 2, 0.0, 'seed', seed, 'proj_dist_fn', 'unif');\ne62 = clugen(3, 4, 1000, [1 0 0], pi / 2, [20 20 20], 13, 2, 1.0, 'seed', seed, 'proj_dist_fn', 'unif');\ne63 = clugen(3, 4, 1000, [1 0 0], pi / 2, [20 20 20], 13, 2, 3.0, 'seed', seed, 'proj_dist_fn', 'unif');\n</code></pre> <pre><code>plot_examples_3d(...\ne61, 'e61: lateral\\_disp = 0', ...\ne62, 'e62: lateral\\_disp = 1', ...\ne63, 'e63: lateral\\_disp = 3');\n</code></pre>"},{"location":"examples/#custom-projection-placement-using-the-beta-distribution_1","title":"Custom projection placement using the Beta distribution","text":"<pre><code>seed = 456;\n% Custom proj_dist_fn: point projections placed using the Beta distribution\n% (requires MATLAB or Octave statistics toolbox)\nproj_beta = @(len, n) len * betarnd(0.1, 0.1, [n 1]) - len / 2;\ne64 = clugen(3, 4, 1000, [1 0 0], pi / 2, [20 20 20], 13, 2, 0.0, 'seed', seed, 'proj_dist_fn', proj_beta);\ne65 = clugen(3, 4, 1000, [1 0 0], pi / 2, [20 20 20], 13, 2, 1.0, 'seed', seed, 'proj_dist_fn', proj_beta);\ne66 = clugen(3, 4, 1000, [1 0 0], pi / 2, [20 20 20], 13, 2, 3.0, 'seed', seed, 'proj_dist_fn', proj_beta);\n</code></pre> <pre><code>plot_examples_3d(...\ne64, 'e64: lateral\\_disp = 0', ...\ne65, 'e65: lateral\\_disp = 1', ...\ne66, 'e66: lateral\\_disp = 3');\n</code></pre>"},{"location":"examples/#controlling-final-point-positions-from-their-projections-on-the-cluster-supporting-line_1","title":"Controlling final point positions from their projections on the cluster-supporting line","text":""},{"location":"examples/#points-on-hyperplane-orthogonal-to-cluster-supporting-line-default-point_dist_fn-n-1_1","title":"Points on hyperplane orthogonal to cluster-supporting line (default): <code>point_dist_fn = \"n-1\"</code>","text":"<pre><code>seed = 34;\n% Custom proj_dist_fn: point projections placed using the Beta distribution\n% (requires MATLAB or Octave statistics toolbox)\nproj_beta = @(len, n) len * betarnd(0.1, 0.1, [n 1]) - len / 2;\ne67 = clugen(3, 5, 1500, [1 0 0], pi / 3, [20 20 20], 22, 3, 2, 'seed', seed);\ne68 = clugen(3, 5, 1500, [1 0 0], pi / 3, [20 20 20], 22, 3, 2, 'seed', seed, 'proj_dist_fn', 'unif');\ne69 = clugen(3, 5, 1500, [1 0 0], pi / 3, [20 20 20], 22, 3, 2, 'seed', seed, 'proj_dist_fn', proj_beta);\n</code></pre> <pre><code>plot_examples_3d(...\ne67, 'e67: proj\\_dist\\_fn = \"norm\" (default)', ...\ne68, 'e68: proj\\_dist\\_fn = \"unif\"', ...\ne69, 'e69: custom proj\\_dist\\_fn (Beta)');\n</code></pre>"},{"location":"examples/#points-around-projection-on-cluster-supporting-line-point_dist_fn-n_1","title":"Points around projection on cluster-supporting line: <code>point_dist_fn = \"n\"</code>","text":"<pre><code>seed = 34;\n% Custom proj_dist_fn: point projections placed using the Beta distribution\n% (requires MATLAB or Octave statistics toolbox)\nproj_beta = @(len, n) len * betarnd(0.1, 0.1, [n 1]) - len / 2;\ne70 = clugen(3, 5, 1500, [1 0 0], pi / 3, [20 20 20], 22, 3, 2, 'seed', seed, ...\n'point_dist_fn', 'n');\ne71 = clugen(3, 5, 1500, [1 0 0], pi / 3, [20 20 20], 22, 3, 2, 'seed', seed, ...\n'point_dist_fn', 'n', 'proj_dist_fn', 'unif');\ne72 = clugen(3, 5, 1500, [1 0 0], pi / 3, [20 20 20], 22, 3, 2, 'seed', seed, ...\n'point_dist_fn', 'n', 'proj_dist_fn', proj_beta);\n</code></pre> <pre><code>plot_examples_3d(...\ne70, 'e70: proj\\_dist\\_fn = \"norm\" (default)', ...\ne71, 'e71: proj\\_dist\\_fn = \"unif\"', ...\ne72, 'e72: custom proj\\_dist\\_fn (Beta)');\n</code></pre>"},{"location":"examples/#custom-point-placement-using-the-exponential-distribution_1","title":"Custom point placement using the exponential distribution","text":"<pre><code>seed = 34;\n% Custom point_dist_fn: final points placed using the Exponential distribution\n% (requires MATLAB or Octave statistics toolbox)\nclupoints_n_1_exp = @(projs, lat_std, len, clu_dir, clu_ctr) ...\nclupoints_n_1_template(projs, lat_std, clu_dir, ...\n@(npts, lstd) lstd * exprnd(2 / lstd, [npts 1]));\n% Custom proj_dist_fn: point projections placed using the Beta distribution\n% (requires MATLAB or Octave statistics toolbox)\nproj_beta = @(len, n) len * betarnd(0.1, 0.1, [n 1]) - len / 2;\ne73 = clugen(3, 5, 1500, [1 0 0], pi / 3, [20 20, 20], 22, 3, 2, 'seed', seed, ...\n'point_dist_fn', clupoints_n_1_exp);\ne74 = clugen(3, 5, 1500, [1 0 0], pi / 3, [20 20 20], 22, 3, 2, 'seed', seed, ...\n'point_dist_fn', clupoints_n_1_exp, 'proj_dist_fn', 'unif');\ne75 = clugen(3, 5, 1500, [1 0 0], pi / 3, [20 20 20], 22, 3, 2, 'seed', seed, ...\n'point_dist_fn', clupoints_n_1_exp, 'proj_dist_fn', proj_beta);\n</code></pre> <pre><code>plot_examples_3d(...\ne73, 'e73: proj\\_dist\\_fn = \"norm\" (default)', ...\ne74, 'e74: proj\\_dist\\_fn = \"unif\"', ...\ne75, 'e75: custom proj\\_dist\\_fn (Beta)');\n</code></pre>"},{"location":"examples/#manipulating-cluster-sizes_1","title":"Manipulating cluster sizes","text":"<pre><code>seed = 543210;\n% Custom clusizes_fn (e77): cluster sizes determined via the uniform distribution,\n% no correction for total points\nclusizes_unif = @(nclu, npts, ae) randi(2 * npts / nclu, nclu, 1);\n% Custom clusizes_fn (e78): clusters all have the same size, no correction for\n% total points\nclusizes_equal = @(nclu, npts, ae) floor(npts / nclu) * ones(nclu, 1);\n% Custom clucenters_fn (all): yields fixed positions for the clusters\ncenters_fixed = @(nclu, csep, coff) ...\n[-csep(1) -csep(2) -csep(3); csep(1) -csep(2) -csep(3); ...\n-csep(1)  csep(2)  csep(3); csep(1)  csep(2)  csep(3)];\ne76 = clugen(3, 4, 1500, [1 1 1], pi, [20 20 20], 0, 0, 5, 'seed', seed, ...\n'clucenters_fn', centers_fixed, 'point_dist_fn', 'n');\ne77 = clugen(3, 4, 1500, [1 1 1], pi, [20 20 20], 0, 0, 5, 'seed', seed, ...\n'clucenters_fn', centers_fixed, 'clusizes_fn', clusizes_unif, 'point_dist_fn', 'n');\ne78 = clugen(3, 4, 1500, [1 1 1], pi, [20 20 20], 0, 0, 5, 'seed', seed, ...\n'clucenters_fn', centers_fixed, 'clusizes_fn', clusizes_equal, 'point_dist_fn', 'n');\n</code></pre> <pre><code>plot_examples_3d(...\ne76, 'e76: normal dist. (default)', ...\ne77, 'e77: unif. dist. (custom)', ...\ne78, 'e78: equal size (custom)');\n</code></pre>"},{"location":"examples/#examples-in-other-dimensions","title":"Examples in other dimensions","text":""},{"location":"examples/#basic-1d-example-with-density-plot","title":"Basic 1D example with density plot","text":"<p>These examples was plotted with the <code>plot_examples_1d()</code> helper function available here.</p> <pre><code>% Custom proj_dist_fn: point projections placed using the Weibull distribution\n% (requires MATLAB or Octave statistics toolbox)\nproj_wbull = @(len, n) wblrnd(len / 2, 1.5, [n 1]) - len / 2;\ne79 = clugen(1, 3, 2000, 1, 0, 10, 6, 1.5, 0, 'seed', 45);\ne80 = clugen(1, 3, 2000, 1, 0, 10, 6, 1.5, 0, 'seed', 45, 'proj_dist_fn', 'unif');\ne81 = clugen(1, 3, 2000, 1, 0, 10, 6, 1.5, 0, 'seed', 45, 'proj_dist_fn', proj_wbull);\n</code></pre> <pre><code>plot_examples_1d(...\ne79, 'e79: proj\\_dist\\_fn = \"norm\" (default)', ...\ne80, 'e80: proj\\_dist\\_fn = \"unif\"', ...\ne81, 'e81: custom proj\\_dist\\_fn (Weibull)');\n</code></pre> <p></p>"},{"location":"examples/#5d-example-with-default-optional-arguments","title":"5D example with default optional arguments","text":"<p>These examples were plotted with the <code>plot_examples_nd()</code> helper function available here.</p> <pre><code>nd = 5;\nseed = 123;\ne82 = clugen(nd, 6, 1500, [1 1 0.5 0 0], pi / 16, 30 * ones(nd, 1), 30, 4, 3, 'seed', seed);\n</code></pre> <pre><code>plot_examples_nd(e82, 'e82: 5D with optional parameters set to defaults');\n</code></pre> <p></p>"},{"location":"examples/#5d-example-with-proj_dist_fn-unif-and-point_dist_fn-n","title":"5D example with <code>proj_dist_fn = \"unif\"</code> and <code>point_dist_fn = \"n\"</code>","text":"<pre><code>nd = 5;\nseed = 321;\ne83 = clugen(nd, 6, 1500, [0.1 0.3 0.5 0.3 0.1], pi / 12, 30 * ones(nd, 1), 35, 5, 3.5, 'seed', seed, ...\n'proj_dist_fn', 'unif', 'point_dist_fn', 'n');\n</code></pre> <pre><code>plt = plot_examples_nd(e83, 'e83: 5D with proj\\_dist\\_fn=\"unif\" and point\\_dist\\_fn=\"n\"');\n</code></pre>"},{"location":"theory/","title":"Theory","text":"<p>This page describes the theoretical framework of the clugen algorithm, starting with a general Overview, then moving on to a Detailed description.</p>"},{"location":"theory/#overview","title":"Overview","text":"<p>Clugen is an algorithm for generating multidimensional clusters. Each cluster is supported by a line segment, the position, orientation and length of which guide where the respective points are placed. For brevity, line segments will be referred to as lines.</p> <p>Given an \\(n\\)-dimensional direction vector \\(\\mathbf{d}\\) (and a number of additional parameters, which will be discussed shortly), the clugen algorithm works as follows (\\(^\\star\\) means the algorithm step is stochastic):</p> <ol> <li>Normalize \\(\\mathbf{d}\\).</li> <li>\\(^\\star\\)Determine cluster sizes.</li> <li>\\(^\\star\\)Determine cluster centers.</li> <li>\\(^\\star\\)Determine lengths of cluster-supporting lines.</li> <li>\\(^\\star\\)Determine angles between \\(\\mathbf{d}\\) and cluster-supporting lines.</li> <li>For each cluster:</li> <li>\\(^\\star\\)Determine direction of the cluster-supporting line.</li> <li>\\(^\\star\\)Determine distance of point projections from the center of the       cluster-supporting line.</li> <li>Determine coordinates of point projections on the cluster-supporting line.</li> <li>\\(^\\star\\)Determine points from their projections on the cluster-supporting       line.</li> </ol> <p>Figure 1 provides a stylized overview of the algorithm's steps.</p> <p> Figure 1 - Stylized overview of the clugen algorithm. Background tiles are 10 units wide and tall, when applicable.</p> <p>The example in Figure 1 was generated with the following parameters, the exact meaning of each will be discussed shortly:</p> Parameter values Description \\(n=2\\) Number of dimensions. \\(c=4\\) Number of clusters. \\(p=200\\) Total number of points. \\(\\mathbf{d}=\\begin{bmatrix}1 &amp; 1\\end{bmatrix}^T\\) Average direction. \\(\\theta_\\sigma=\\pi/16\\approx{}11.25^{\\circ}\\) Angle dispersion. \\(\\mathbf{s}=\\begin{bmatrix}10 &amp; 10\\end{bmatrix}^T\\) Average cluster separation. \\(l=10\\) Average line length. \\(l_\\sigma=1.5\\) Line length dispersion. \\(f_\\sigma=1\\) Cluster lateral dispersion. <p>Additionally, all optional parameters (not listed above) were left to their default values. These will also be discussed next.</p>"},{"location":"theory/#detailed-description","title":"Detailed description","text":"<p>In this section we provide a detailed description of the algorithm and its parameters. We start by listing and describing all parameters (mandatory and optional), and then analyze the algorithm in detail, highlighting how each parameter influences the end result.</p>"},{"location":"theory/#algorithm-parameters","title":"Algorithm parameters","text":"<p>The clugen algorithm (and consequently, the <code>clugen()</code> function) has mandatory and optional parameters, listed and described in the tables below. The optional parameters are set to sensible defaults, and in many situations may be left unchanged. Nonetheless, these allow all of the algorithm's steps to be fully customized by the user.</p>"},{"location":"theory/#mandatory-parameters","title":"Mandatory parameters","text":"Symbol Parameter Description \\(n\\) <code>num_dims</code> Number of dimensions. \\(c\\) <code>num_clusters</code> Number of clusters. \\(p\\) <code>num_points</code> Total number of points to generate. \\(\\mathbf{d}\\) <code>direction</code> Average direction of cluster-supporting lines (\\(n \\times 1\\)). \\(\\theta_\\sigma\\) <code>angle_disp</code> Angle dispersion of cluster-supporting lines (radians). \\(\\mathbf{s}\\) <code>cluster_sep</code> Average cluster separation in each dimension (\\(n \\times 1\\)). \\(l\\) <code>llength</code> Average length of cluster-supporting lines. \\(l_\\sigma\\) <code>llength_disp</code> Length dispersion of cluster-supporting lines. \\(f_\\sigma\\) <code>lateral_disp</code> Cluster lateral dispersion, i.e., dispersion of points from their projection on the cluster-supporting line."},{"location":"theory/#optional-parameters","title":"Optional parameters","text":"Symbol Parameter Default value Description \\(\\phi\\) <code>allow_empty</code> <code>false</code> Allow empty clusters? \\(\\mathbf{o}\\) <code>cluster_offset</code> <code>zeros(num_dims, 1)</code> Offset to add to all cluster centers (\\(n \\times 1\\)). \\(p_\\text{proj}()\\) <code>proj_dist_fn</code> <code>\"norm\"</code> Distribution of point projections along cluster-supporting lines. \\(p_\\text{final}()\\) <code>point_dist_fn</code> <code>\"n-1\"</code> Distribution of final points from their projections. \\(c_s()\\) <code>clusizes_fn</code> <code>clusizes()</code> Distribution of cluster sizes. \\(c_c()\\) <code>clucenters_fn</code> <code>clucenters()</code> Distribution of cluster centers. \\(l()\\) <code>llengths_fn</code> <code>llengths()</code> Distribution of line lengths. \\(\\theta_\\Delta()\\) <code>angle_deltas_fn</code> <code>angle_deltas()</code> Distribution of line angle deltas (w.r.t. \\(\\mathbf{d}\\))."},{"location":"theory/#the-algorithm-in-detail","title":"The algorithm in detail","text":"<p>The clugen algorithm is presented in Overview. In this section we will analyze each of the algorithms steps in detail.</p>"},{"location":"theory/#1-normalize-mathbfd","title":"1. Normalize \\(\\mathbf{d}\\)","text":"<p>This is a basic step, which consists of converting \\(\\mathbf{d}\\) to a unit vector:</p> \\[ \\hat{\\mathbf{d}} = \\cfrac{\\mathbf{d}}{\\left\\lVert\\mathbf{d}\\right\\rVert} \\]"},{"location":"theory/#2-determine-cluster-sizes","title":"2. Determine cluster sizes","text":"<p>Cluster sizes are given by the \\(c_s()\\) function according to:</p> \\[ \\mathbf{c_s} = c_s(c, p, \\phi) \\] <p>where \\(\\mathbf{c_s}\\) is an \\(c \\times 1\\) integer vector containing the final cluster sizes, \\(c\\) is the number of clusters, \\(p\\) is the total number of points, and \\(\\phi\\) is a boolean which determines whether empty clusters are acceptable.</p> <p>The \\(c_s()\\) function is an optional parameter, allowing users to customize its behavior. By default, \\(c_s()\\) is implemented by the <code>clusizes()</code> function, which behaves according to the following algorithm:</p> <ol> <li>Determine the size \\(p_i\\) of each cluster \\(i\\) according to    \\(p_i\\sim\\left\\lfloor\\max\\left(\\mathcal{N}(\\frac{p}{c}, (\\frac{p}{3c})^2),0\\right)\\right\\rceil\\),    where \\(\\lfloor\\rceil\\) denotes the round to nearest integer function, and     \\(\\mathcal{N}(\\mu,\\sigma^2)\\) represents the normal distribution with    mean \\(\\mu\\) and variance \\(\\sigma^2\\).</li> <li>Assure that the final cluster sizes add up to \\(p\\) by incrementing the smallest    cluster size while \\(\\sum_{i=1}^c p_i&lt;p\\) or decrementing the largest cluster    size while \\(\\sum_{i=1}^c p_i&gt;p\\). This step is delegated to the    <code>fix_num_points()</code> helper function.</li> <li>If \\(\\neg\\phi\\wedge p\\ge c\\) then, for each empty cluster \\(i\\) (i.e.,    \\(p_i=0\\)), increment \\(p_i\\) and decrement \\(p_j\\), where \\(j\\) denotes the    largest cluster. This step is delegated to the    <code>fix_empty()</code> helper function.</li> </ol> <p>Figure 2 demonstrates possible cluster sizes with various definitions of \\(c_s()\\) for \\(c=4\\) and \\(p=5000\\). The default behavior, implemented in the <code>clusizes()</code> function, is shown in Figure 2a, while Figures 2b-d present results obtained with custom user functions. Figure 2b displays cluster sizes obtained with the discrete uniform distribution over \\(\\left\\{1, 2, \\ldots, \\frac{2p}{c}\\right\\}\\), corrected with <code>fix_num_points()</code>. In turn, Figure 2c highlights cluster sizes obtained with the Poisson distribution with \\(\\lambda=\\frac{p}{c}\\), also corrected with <code>fix_num_points()</code>. The cluster sizes shown in Figure 2d were determined with the same distribution (Poisson, \\(\\lambda=\\frac{p}{c}\\)), but were not corrected. Thus, cluster sizes do not add up to \\(p\\), highlighting the fact that this is not a requirement of the clugen algorithm, i.e., user-defined  \\(c_s()\\) implementations can consider \\(p\\) a hint rather than an obligation.</p> <p> Figure 2 - Possible cluster sizes with various definitions of \\(c_s()\\) for \\(c=4\\) and \\(p=5000\\).</p>"},{"location":"theory/#3-determine-cluster-centers","title":"3. Determine cluster centers","text":"<p>Cluster sizes are given by the \\(c_c()\\) function according to:</p> \\[ \\mathbf{C} = c_c(c, \\mathbf{s}, \\mathbf{o}) \\] <p>where \\(\\mathbf{C}\\) is an \\(c \\times n\\) matrix containing the final cluster centers, \\(c\\) is the number of clusters, \\(\\mathbf{s}\\) is the average cluster separation (\\(n \\times 1\\) vector), and \\(\\mathbf{o}\\) is an \\(n \\times 1\\) vector of cluster offsets.</p> <p>The \\(c_c()\\) function is an optional parameter, allowing users to customize its behavior. By default, \\(c_c()\\) is implemented by the <code>clucenters()</code> function, which determines the cluster centers according to:</p> \\[ \\mathbf{C}=c\\mathbf{U} \\cdot \\operatorname{diag}(\\mathbf{s}) + \\mathbf{1}\\,\\mathbf{o}^T \\] <p>where \\(\\mathbf{U}\\) is an \\(c \\times n\\) matrix of random values drawn from the uniform distribution between -0.5 and 0.5, and \\(\\mathbf{1}\\) is an \\(c \\times 1\\) vector with all entries equal to 1.</p> <p>Figure 3 shows scatters plots of the results generated by clugen for two different implementations of the \\(c_c()\\) function, namely using the uniform the distribution (the default, implemented by the <code>clucenters()</code> function, Figure 3a), and direct specification of cluster centers (Figure 3b).</p> <p> Figure 3 - The output of clugen for two different implementations of the \\(c_c()\\) function for finding cluster centers: a) the default, using the uniform distribution; b) hand-picked centers. All parameters are the same as in Figure 1, except for \\(p\\), which is set to 5000.</p>"},{"location":"theory/#4-determine-lengths-of-cluster-supporting-lines","title":"4. Determine lengths of cluster-supporting lines","text":"<p>The lengths of the cluster-supporting lines are given by the \\(l()\\) function according to:</p> \\[ \\pmb{\\ell} = l(c, l, l_\\sigma) \\] <p>where \\(\\pmb{\\ell}\\) is an \\(c \\times 1\\) vector containing the final lengths of the cluster-supporting lines, \\(c\\) is the number of clusters, \\(l\\) is the average length, and \\(l_\\sigma\\) is the length dispersion.</p> <p>The \\(l()\\) function is an optional parameter, allowing users to customize its behavior. By default, \\(l()\\) is implemented by the <code>llengths()</code> function, which determines the \\(\\ell_i\\) length of each cluster-supporting line \\(i\\) according to:</p> \\[ \\ell_i\\sim\\left|\\mathcal{N}(l,l_\\sigma^2)\\right| \\] <p>where \\(\\left|\\mathcal{N}(\\mu,\\sigma^2)\\right|\\) represents the folded normal distribution with mean \\(\\mu\\) and variance \\(\\sigma^2\\).</p> <p>Figure 4 shows cluster-supporting line lengths obtained with different implementations of \\(l()\\).</p> <p> Figure 4 - Line lengths for different implementations of \\(l()\\): a) the default, using the folded normal distribution; b) using the Poisson distribution, with \\(\\lambda=l\\); c) using the uniform distribution in the interval \\(\\left\\lbrack 0, 2l\\right\\rbrack\\); and, d) hand-picked lengths, more specifically \\(\\pmb{\\ell}=\\begin{bmatrix}2 &amp; 8 &amp; 16 &amp; 32\\end{bmatrix}^T\\). Cluster centers, as well as parameters \\(l\\) and \\(l_\\sigma\\), are the same as for the example shown in Figure 1.</p>"},{"location":"theory/#5-determine-angles-between-mathbfd-and-cluster-supporting-lines","title":"5. Determine angles between \\(\\mathbf{d}\\) and cluster-supporting lines","text":"<p>The angles between \\(\\mathbf{d}\\) and the cluster-supporting lines are given by the \\(\\theta_\\Delta()\\) function according to:</p> \\[ \\mathbf{\\Theta_\\Delta} = \\theta_\\Delta(c, \\theta_\\sigma) \\] <p>where \\(\\mathbf{\\Theta_\\Delta}\\) is an \\(c \\times 1\\) vector containing the final angle differences between \\(\\mathbf{d}\\) and the cluster-supporting lines, \\(c\\) is the number of clusters, and \\(\\theta_\\sigma\\) is the angle dispersion.</p> <p>The \\(\\theta_\\Delta()\\) function is an optional parameter, allowing users to customize its behavior. By default, \\(\\theta_\\Delta()\\) is implemented by the <code>angle_deltas()</code> function, which determines the \\(\\theta_{\\Delta i}\\) angle difference between \\(\\mathbf{d}\\) and the \\(i\\)-th cluster-supporting line according to:</p> \\[ \\theta_{\\Delta i}\\sim\\mathcal{WN}_{-\\pi/2}^{\\pi/2}(0,\\theta_\\sigma^2) \\] <p>where \\(\\mathcal{WN}_{-\\pi/2}^{\\pi/2}(\\mu,\\sigma^2)\\) represents the wrapped normal distribution with mean \\(\\mu\\), variance \\(\\sigma^2\\), and support in the \\(\\left[-\\pi/2,\\pi/2\\right]\\) interval, and \\(\\theta_\\sigma\\) is the angle dispersion of the cluster-supporting lines.</p> <p>Figure 5 shows the final direction of the cluster-supporting lines for two different implementations of \\(\\theta_\\Delta()\\).</p> <p> Figure 5 - Final directions of the cluster supporting-lines for different implementations of \\(\\theta_\\Delta()\\): a) the default, where angle differences were obtained using the wrapped normal distribution; and, d) hand-picked angle differences, more specifically \\(\\mathbf{\\Theta_\\Delta}=\\begin{bmatrix}0 &amp; \\frac{\\pi}{2} &amp; 0 &amp; \\frac{\\pi}{2}\\end{bmatrix}^T\\). Cluster centers, as well as the angle dispersion \\(\\theta_\\sigma\\), are the same as for the example shown in Figure 1.</p>"},{"location":"theory/#6-for-each-cluster-i","title":"6. For each cluster \\(i\\):","text":""},{"location":"theory/#61-determine-direction-of-the-cluster-supporting-line","title":"6.1. Determine direction of the cluster-supporting line","text":"<p>In order to obtain the \\(\\hat{\\mathbf{d}}_i\\) final direction of cluster \\(i\\) supporting line, the following algorithm is used:</p> <ul> <li>1. Find random vector \\(\\mathbf{r}\\) with each component taken from the   uniform distribution between -0.5 and 0.5.</li> <li>2. Normalize \\(\\mathbf{r}\\):</li> </ul> \\[ \\hat{\\mathbf{r}}=\\cfrac{\\mathbf{r}}{\\left\\lVert\\mathbf{r}\\right\\rVert} \\] <ul> <li>3. If \\(|\\theta_{\\Delta i}| &gt; \\pi/2\\) or \\(n=1\\), set   \\(\\hat{\\mathbf{d}}_i=\\hat{\\mathbf{r}}\\) and terminate the algorithm.</li> <li>4. If \\(\\hat{\\mathbf{r}}\\) is parallel to \\(\\hat{\\mathbf{d}}\\) go to 1.</li> <li>5. Determine vector \\(\\mathbf{d}_\\perp\\) orthogonal to \\(\\hat{\\mathbf{d}}\\)   using the first iteration of the Gram-Schmidt process:</li> </ul> \\[ \\mathbf{d}_\\perp=\\hat{\\mathbf{r}}-\\cfrac{\\hat{\\mathbf{d}}\\cdot\\hat{\\mathbf{r}}}{\\hat{\\mathbf{d}}\\cdot\\hat{\\mathbf{d}}}\\:\\hat{\\mathbf{d}} \\] <ul> <li>6. Normalize \\(\\mathbf{d}_\\perp\\):</li> </ul> \\[ \\hat{\\mathbf{d}}_\\perp=\\cfrac{\\mathbf{d}_\\perp}{\\left\\lVert\\mathbf{d}_\\perp\\right\\rVert} \\] <ul> <li>7. Determine vector \\(\\mathbf{d}_i\\) at angle \\(\\theta_{\\Delta i}\\) with   \\(\\hat{\\mathbf{d}}\\):</li> </ul> \\[ \\mathbf{d}_i=\\hat{\\mathbf{d}}+\\tan(\\theta_{\\Delta i})\\hat{\\mathbf{d}}_\\perp \\] <ul> <li>8. Normalize \\(\\mathbf{d}_i\\):</li> </ul> \\[ \\hat{\\mathbf{d}}_i=\\cfrac{\\mathbf{d}_i}{\\left\\lVert\\mathbf{d}_i\\right\\rVert} \\]"},{"location":"theory/#62-determine-distance-of-point-projections-from-the-center-of-the-cluster-supporting-line","title":"6.2. Determine distance of point projections from the center of the cluster-supporting line","text":"<p>The distance of point projections from the center of the cluster-supporting line is given by the \\(p_\\text{proj}()\\) function according to:</p> \\[ \\mathbf{w}_i = p_\\text{proj}(\\ell_i, p_i) \\] <p>where \\(\\mathbf{w}_i\\) is an \\(p_i \\times 1\\) vector containing the distance of each point projection to the center of the line, while \\(\\ell_i\\) and \\(p_i\\) are the line length and number of points in cluster \\(i\\), respectively.</p> <p>The \\(p_\\text{proj}()\\) function is an optional parameter, allowing users to customize its behavior. <code>MOClugGen</code> provides two concrete implementations out of the box, specified by passing <code>\"norm\"</code> or <code>\"unif\"</code> to <code>clugen()</code>'s <code>proj_dist_fn</code> parameter. These work as follows:</p> <ul> <li><code>\"norm\"</code> (default) - Each element of \\(\\mathbf{w}_i\\) is derived from   \\(\\mathcal{N}(0, (\\frac{\\ell_i}{6})^2)\\), i.e., from the normal distribution,   centered on the cluster-supporting line center (\\(\\mu=0\\)) and with a standard   deviation of \\(\\sigma=\\frac{\\ell_i}{6}\\), such that the length of the line   segment encompasses \\(\\approx\\) 99.73% of the generated projections. Consequently,   some projections may be placed outside the line's end points.</li> <li><code>\"unif\"</code> - Each element of \\(\\mathbf{w}_i\\) is derived from   \\(\\mathcal{U}(-\\frac{\\ell_i}{2}, \\frac{\\ell_i}{2})\\), i.e., from the continuous   uniform distribution in the interval \\(\\left[-\\frac{\\ell_i}{2}, \\frac{\\ell_i}{2}\\right[\\).   Thus, projections will be uniformly dispersed along the cluster-supporting line.</li> </ul> <p>The impact of various implementations of \\(p_\\text{proj}()\\) is demonstrated in Figure 6. Figures 6a and 6b show the clusters generated with the <code>\"norm\"</code> and <code>\"unif\"</code> options, respectively, while Figures 6c and 6d highlight custom user functions implementing the Laplace and Rayleigh distributions, respectively. All parameters are set as in Figure 1, except for \\(p_\\text{proj}()\\) in the case of Figures 6b-6d, and \\(p\\), which is set to 5000.</p> <p> Figure 6 - Clusters generated for various implementations of \\(p_\\text{proj}()\\): a) the default, where line center distances are drawn for the normal distribution, specified using the in-built <code>\"norm\"</code> option; b) in which center distances are derived from the uniform distribution, via the in-built <code>\"unif\"</code> option; c) where line center distances are obtained from a custom user function implementing the Laplace distribution; and, d) in which a custom user function returns center distances drawn from the Rayleigh distribution. All parameters are set as in Figure 1, except for \\(p_\\text{proj}()\\) in the case of Figures 6b-6d, and \\(p\\), which is set to 5000.</p>"},{"location":"theory/#63-determine-coordinates-of-point-projections-on-the-cluster-supporting-line","title":"6.3. Determine coordinates of point projections on the cluster-supporting line","text":"<p>This is a deterministic step performed by the <code>points_on_line()</code> function using the vector formulation of the line equation, as follows:</p> \\[ \\mathbf{P}_i^\\text{proj}=\\mathbf{1}\\,\\mathbf{c}_i^T + \\mathbf{w}_i\\hat{\\mathbf{d}}_i^T \\] <p>where \\(\\mathbf{P}_i^\\text{proj}\\) is the \\(p_i \\times n\\) matrix of point projection coordinates on the line, \\(\\mathbf{1}\\) is an \\(p_i \\times 1\\) vector with all entries equal to 1, \\(\\mathbf{c}_i\\) are the coordinates of the line center (\\(n \\times 1\\) vector), \\(\\mathbf{w}_i\\) is the distance of each point projection to the center of the line (\\(p_i \\times 1\\) vector obtained in the previous step), and \\(\\hat{\\mathbf{d}}_i\\) is the direction of the cluster-supporting line for cluster \\(i\\).</p>"},{"location":"theory/#64-determine-points-from-their-projections-on-the-cluster-supporting-line","title":"6.4. Determine points from their projections on the cluster-supporting line","text":"<p>The final cluster points, obtained from their projections on the cluster-supporting line, are given by the \\(p_\\text{final}()\\) function according to:</p> \\[ \\mathbf{P}_i^\\text{final} = p_\\text{final}(\\mathbf{P}_i^\\text{proj}, f_\\sigma, \\ell_i, \\hat{\\mathbf{d}}_i, \\mathbf{c}_i) \\] <p>where \\(\\mathbf{P}_i^\\text{final}\\) is a \\(p_i \\times n\\) matrix containing the coordinates of the generated points, \\(\\mathbf{P}_i^\\text{proj}\\) is the \\(p_i \\times n\\) matrix of projection coordinates (determined in the previous step), and \\(f_\\sigma\\) is the lateral dispersion parameter. In turn, \\(\\ell_i\\), \\(\\hat{\\mathbf{d}}_i\\) and \\(\\mathbf{c}_i\\) are the length, direction and center of the cluster-supporting line.</p> <p>The \\(p_\\text{final}()\\) function is an optional parameter, allowing users to customize its behavior. <code>MOCluGen</code> provides two concrete implementations out of the box, specified by passing <code>\"n-1\"</code> or <code>\"n\"</code> to <code>clugen()</code>'s <code>point_dist_fn</code> parameter. These work as follows:</p> <ul> <li><code>\"n-1\"</code> (default) - Points are placed on a hyperplane orthogonal to the   cluster-supporting line and intersecting the point's projection. This is done   by obtaining \\(p_i\\) random unit vectors orthogonal to \\(\\hat{\\mathbf{d}}_i\\),   and determining their magnitude using the normal distribution   (\\(\\mu=0\\), \\(\\sigma=f_\\sigma\\)). These vectors are then added to the respective   projections on the cluster-supporting line, yielding the final cluster points.   This behavior is implemented in the   <code>clupoints_n_1()</code> function.</li> <li><code>\"n\"</code> - Points are placed around their respective projections. This is done by   obtaining \\(p_i\\) random unit vectors, and determining their magnitude using   the normal distribution (\\(\\mu=0\\), \\(\\sigma=f_\\sigma\\)). These vectors are   then added to the respective projections on the cluster-supporting line,   yielding the final cluster points. This behavior is implemented in the   <code>clupoints_n()</code> function.</li> </ul> <p>Figure 7 highlights the differences between these two approaches in 2D, where a hyperplane is simply a line.</p> <p> Figure 7 - Example of how the final cluster points are obtained in 2D when using the built-in implementations for \\(p_\\text{final}()\\).</p> <p>In general, points can be placed using a <code>\"n-1\"</code> or <code>\"n\"</code> strategy using any distribution. Figure 8 displays several examples for various implementations of \\(p_\\text{final}()\\), either based on <code>\"n-1\"</code> or <code>\"n\"</code> strategy, using different distributions. Figures 8a and 8b show the built-in <code>\"n-1\"</code> and <code>\"n\"</code> strategies making use of the normal distribution. Figures 8c-8f highlight some possibilities with custom user functions. Figure 8c shows the effect of using the exponential distribution in a <code>\"n-1\"</code> strategy, while Figure 8d displays the result of using a bimodal distribution with the same strategy. A more complex distribution, producing \"hollow\" clusters with a <code>\"n\"</code> strategy, is employed in Figures 8e and 8f, with the latter also having the \\(p_\\text{proj}()\\) function set to <code>\"unif\"</code>. The remaining parameters (for all subfigures) are set as in Figure 1, except for \\(p\\), which is set to 5000.</p> <p></p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#note-on-reproducibility","title":"Note on reproducibility","text":"<p>Functions marked with \\(^\\star\\) are stochastic. Thus, in order to obtain the same result on separate invocations of these functions, it is first necessary to define a seed for the pseudo-random number generator (PRNG). Since this is accomplished in slightly different ways in MATLAB and Octave, <code>MOCluGen</code> provides the <code>cluseed</code> helper function for setting the PRNG seed regardless of the underlying platform. For example:</p> <pre><code>cluseed(123);\nv = rand_unit_vector(3); % Given the same platform, will always return the same vector\n</code></pre> <p>Further, the main <code>clugen</code> function also provides a <code>seed</code> parameter, which is passed directly to <code>cluseed</code>.</p>"},{"location":"reference/#main-function","title":"Main function","text":"<ul> <li><code>clugen</code> \\(^\\star\\)</li> </ul>"},{"location":"reference/#core-functions","title":"Core functions","text":"<ul> <li><code>points_on_line</code></li> <li><code>rand_ortho_vector</code> \\(^\\star\\)</li> <li><code>rand_unit_vector</code> \\(^\\star\\)</li> <li><code>rand_vector_at_angle</code> \\(^\\star\\)</li> </ul>"},{"location":"reference/#algorithm-module-functions","title":"Algorithm module functions","text":"<ul> <li><code>angle_deltas</code> \\(^\\star\\)</li> <li><code>clucenters</code> \\(^\\star\\)</li> <li><code>clupoints_n_1</code> \\(^\\star\\)</li> <li><code>clupoints_n</code> \\(^\\star\\)</li> <li><code>clusizes</code> \\(^\\star\\)</li> <li><code>llengths</code> \\(^\\star\\)</li> </ul>"},{"location":"reference/#helper-functions","title":"Helper functions","text":"<ul> <li><code>angle_btw</code></li> <li><code>clupoints_n_1_template</code> \\(^\\star\\)</li> <li><code>cluseed</code></li> <li><code>fix_empty</code></li> <li><code>fix_num_points</code></li> </ul>"},{"location":"reference/angle_btw/","title":"angle_btw","text":"<p>Angle between two \\(n\\)-dimensional vectors.</p> <pre><code>a = angle_btw(v1, v2)\n</code></pre> <p>Typically, the angle between two vectors <code>v1</code> and <code>v2</code> can be obtained with:</p> <pre><code>acos(dot(v1, v2) / (norm(v1) * norm(v2)))\n</code></pre> <p>However, this approach is numerically unstable. The version provided here is numerically stable and based on the AngleBetweenVectors Julia package by Jeffrey Sarnoff (MIT license), implementing an algorithm provided by Prof. W. Kahan in these notes (see page 15).</p>"},{"location":"reference/angle_btw/#arguments","title":"Arguments","text":"<ul> <li><code>v1</code> - First vector.</li> <li><code>v2</code> - Second vector.</li> </ul>"},{"location":"reference/angle_btw/#return-values","title":"Return values","text":"<ul> <li><code>a</code>- Angle between <code>v1</code> and <code>v2</code> in radians.</li> </ul>"},{"location":"reference/angle_btw/#examples","title":"Examples","text":"<pre><code>v1 = [1.0, 1.0, 1.0, 1.0];\nv2 = [1.0, 0.0, 0.0, 0.0];\nrad2deg(angle_btw(v1, v2)) % Should be 60 degrees\n% ans = 60.000\n</code></pre>"},{"location":"reference/angle_deltas/","title":"angle_deltas","text":"<p>Determine the angles between the average cluster direction and the cluster-supporting lines using the wrapped normal distribution (\u03bc=0, \u03c3=<code>angle_disp</code>) with support in the interval [-\u03c0/2, \u03c0/2].</p> <pre><code>angd = angle_deltas(num_clusters, angle_disp)\n</code></pre>"},{"location":"reference/angle_deltas/#arguments","title":"Arguments","text":"<ul> <li><code>num_clusters</code> - Number of clusters.</li> <li><code>angle_disp</code> - Angle dispersion, in radians.</li> </ul>"},{"location":"reference/angle_deltas/#return-values","title":"Return values","text":"<ul> <li><code>angles</code> - Angles between the average cluster direction and the   cluster-supporting lines, given in radians in the interval [-\u03c0/2, \u03c0/2].</li> </ul>"},{"location":"reference/angle_deltas/#note","title":"Note","text":"<p>This function is stochastic. For reproducibility set the PRNG seed with <code>cluseed()</code> as discussed in the Reference.</p>"},{"location":"reference/angle_deltas/#examples","title":"Examples","text":"<pre><code>cluseed(123);                   % Seed set to 123\narad = angle_deltas(4, pi / 8); % Angle dispersion of 22.5 degrees\nrad2deg(arad')                  % Show angle deltas in degrees\n% ans =\n%\n%     4.3613   21.0290  -33.2926    5.7669\n</code></pre>"},{"location":"reference/clucenters/","title":"clucenters","text":"<p>Determine cluster centers using the uniform distribution, taking into account the number of clusters (<code>num_clusters</code>) and the average cluster separation (<code>clu_sep</code>).</p> <pre><code>clu_centers = clucenters(num_clusters, clu_sep, clu_offset)\n</code></pre> <p>More specifically, let \\(c=\\) <code>num_clusters</code>, \\(\\mathbf{s}=\\) <code>clu_sep</code>, \\(\\mathbf{o}=\\) <code>clu_offset</code>, \\(n=\\) <code>numel(clu_sep)</code> (i.e., number of dimensions). Cluster centers are obtained according to the following equation:</p> \\[ \\mathbf{C}=c\\mathbf{U} \\cdot \\operatorname{diag}(\\mathbf{s}) + \\mathbf{1}\\,\\mathbf{o}^T \\] <p>where \\(\\mathbf{C}\\) is the \\(c \\times n\\) matrix of cluster centers, \\(\\mathbf{U}\\) is an \\(c \\times n\\) matrix of random values drawn from the uniform distribution between -0.5 and 0.5, and \\(\\mathbf{1}\\) is an \\(c \\times 1\\) vector with all entries equal to 1.</p>"},{"location":"reference/clucenters/#arguments","title":"Arguments","text":"<ul> <li><code>num_clusters</code> - Number of clusters.</li> <li><code>clu_sep</code> - Average cluster separation (\\(n \\times 1\\) vector).</li> <li><code>clu_offset</code> - Cluster offsets (\\(n \\times 1\\) vector).</li> </ul>"},{"location":"reference/clucenters/#return-values","title":"Return values","text":"<ul> <li><code>clu_centers</code> - A \\(c \\times n\\) matrix containing the cluster centers.</li> </ul>"},{"location":"reference/clucenters/#note","title":"Note","text":"<p>This function is stochastic. For reproducibility set the PRNG seed with <code>cluseed()</code> as discussed in the Reference.</p>"},{"location":"reference/clucenters/#examples","title":"Examples","text":"<pre><code>cluseed(123);                      % Seed set to 123\nclucenters(3, [30; 10], [-50; 50]) % Get centers for 3 clusters in 2D\n% ans =\n%\n%   -90.287   38.231\n%   -87.153   62.036\n%   -58.348   36.145\n</code></pre>"},{"location":"reference/clugen/","title":"clugen","text":"<p>Generate multidimensional clusters.</p> <pre><code>cludata = clugen( ...\nnum_dims, ...\nnum_clusters, ...\nnum_points, ...\ndirection, ...\nangle_disp, ...\ncluster_sep, ...\nllength, ...\nllength_disp, ...\nlateral_disp, ...\nvarargin)\n</code></pre> <p>This is the main function of the MOCluGen package, and possibly the only function most users will need.</p>"},{"location":"reference/clugen/#arguments-mandatory","title":"Arguments (mandatory)","text":"<ul> <li><code>num_dims</code>: Number of dimensions.</li> <li><code>num_clusters</code>: Number of clusters to generate.</li> <li><code>num_points</code>: Total number of points to generate.</li> <li><code>direction</code>: Average direction of the cluster-supporting lines (vector of   <code>num_dims</code> elements).</li> <li><code>angle_disp</code>: Angle dispersion of cluster-supporting lines (radians).</li> <li><code>cluster_sep</code>: Average cluster separation in each dimension (vector of   <code>num_dims</code> elements).</li> <li><code>llength</code>: Average length of cluster-supporting lines.</li> <li><code>llength_disp</code>: Length dispersion of cluster-supporting lines.</li> <li><code>lateral_disp</code>: Cluster lateral dispersion, i.e., dispersion of points from their   projection on the cluster-supporting line.</li> </ul> <p>Note that the terms \"average\" and \"dispersion\" refer to measures of central tendency and statistical dispersion, respectively. Their exact meaning depends on the optional arguments, described next.</p>"},{"location":"reference/clugen/#arguments-optional","title":"Arguments (optional)","text":"<ul> <li><code>allow_empty</code>: Allow empty clusters? <code>false</code> by default.</li> <li><code>cluster_offset</code>: Offset to add to all cluster centers. By default the offset   will be equal to <code>zeros(num_dims, 1)</code>.</li> <li><code>proj_dist_fn</code>: Distribution of point projections along cluster-supporting lines,   with three possible values:<ul> <li><code>'norm'</code> (default): Distribute point projections along lines using a normal   distribution (\u03bc=line center, \u03c3=<code>llength/6</code>).</li> <li><code>'unif'</code>: Distribute points uniformly along the line.</li> <li>User-defined function, which accepts two parameters, line length (float) and   number of points (integer), and returns an array containing the distance of   each point projection to the center of the line. For example, the <code>\"norm\"</code>   option roughly corresponds to <code>@(len, n) len * randn(n, 1) / 6</code>.</li> </ul> </li> <li><code>point_dist_fn</code>: Controls how the final points are created from their projections   on the cluster-supporting lines, with three possible values:<ul> <li><code>'n-1'</code> (default): Final points are placed on a hyperplane orthogonal to   the cluster-supporting line, centered at each point's projection, using the   normal distribution (\u03bc=0, \u03c3=<code>lateral_disp</code>). This is done by the   <code>clupoints_n_1()</code> function.</li> <li><code>'n'</code>: Final points are placed around their projection on the cluster-supporting   line using the normal distribution (\u03bc=0, \u03c3=<code>lateral_disp</code>). This is done by the   <code>clupoints_n()</code> function.</li> <li>User-defined function: The user can specify a custom point placement strategy   by passing a function with the same signature as <code>clupoints_n_1()</code>and   `clupoints_n().</li> </ul> </li> <li><code>clusizes_fn</code>: Distribution of cluster sizes. By default, cluster sizes are   determined by the <code>clusizes()</code> function, which uses the normaldistribution   (\u03bc=<code>num_points</code>/<code>num_clusters</code>, \u03c3=\u03bc/3), and assures that the finalcluster   sizes add up to <code>num_points</code>. This parameter allows the user to specify a   custom function for this purpose, which must follow <code>clusizes()</code>signature.   Note that custom functions are not required to strictly obey the <code>num_points</code>   parameter.</li> <li><code>clucenters_fn</code>: Distribution of cluster centers. By default, cluster centers   are determined by the <code>clucenters()</code> function, which uses the uniform   distribution, and takes into account the <code>num_clusters</code> and <code>cluster_sep</code>   parameters for generating well-distributed cluster centers. This parameter allows   the user to specify a custom function for this purpose, which must follow   <code>clucenters()</code> signature.</li> <li><code>llengths_fn</code>: Distribution of line lengths. By default, the lengths of   cluster-supporting lines are determined by the <code>llengths()</code> function, which   uses the folded normal distribution (\u03bc=<code>llength</code>, \u03c3=<code>llength_disp</code>). This   parameter allows the user to specify a custom function for this purpose, which   must follow <code>llengths()</code> signature.</li> <li><code>angle_deltas_fn</code>: Distribution of line angle differences with respect to <code>direction</code>.   By default, the angles between <code>direction</code> and the direction of cluster-supporting   lines are determined by the <code>angle_deltas()</code> function, which uses the wrapped   normal distribution (\u03bc=0, \u03c3=<code>angle_disp</code>) with support in the interval   [-\u03c0/2, \u03c0/2]. This parameter allows the user to specify a custom function for this   purpose, which must follow <code>angle_deltas()</code> signature.</li> <li><code>seed</code>: Non-negative integer for initializing the PRNG, allowing for   reproducible results; alternatively, the PRNG can be initialized with the   <code>cluseed()</code> function, or by directly setting the seed in MATLAB or Octave   (each using its own specific approach).</li> </ul>"},{"location":"reference/clugen/#return-values","title":"Return values","text":"<p>A <code>struct</code> with the following fields:</p> <ul> <li><code>points</code>: A <code>num_points</code> x <code>num_dims</code> matrix with the generated points for   all clusters.</li> <li><code>clusters</code>: A <code>num_points</code> x 1 vector indicating which cluster each point in   <code>points</code> belongs to.</li> <li><code>projections</code>: A <code>num_points</code> x <code>num_dims</code> matrix with the point projections   on the cluster-supporting lines.</li> <li><code>sizes</code>: A <code>num_clusters</code> x 1 vector with the number of points in each   cluster.</li> <li><code>centers</code>: A <code>num_clusters</code> x <code>num_dims</code> matrix with the coordinates of the   cluster centers.</li> <li><code>directions</code>: A <code>num_clusters</code> x <code>num_dims</code> matrix with the direction of   each cluster-supporting line.</li> <li><code>angles</code>: A <code>num_clusters</code> x 1 vector with the angles between the   cluster-supporting lines and the main direction.</li> <li><code>lengths</code>: A <code>num_clusters</code> x 1 vector with the lengths of the   cluster-supporting lines.</li> </ul> <p>Note that if a custom function was given in the <code>clusizes_fn</code> parameter, it is possible that <code>num_points</code> may have a different value than what was specified in <code>clugen</code>'s <code>num_points</code> parameter.</p>"},{"location":"reference/clugen/#note","title":"Note","text":"<p>This function is stochastic. For reproducibility use the <code>seed</code> parameter or set the PRNG seed as discussed in the Reference.</p>"},{"location":"reference/clugen/#examples","title":"Examples","text":"<pre><code>o = clugen(3, 4, 1000, [1 0 0], pi / 8, [20 15 25], 16, 4, 3.5, 'seed', 123);\n</code></pre> <p>This creates 4 clusters in 3D space with a total of 1000 points, with a main direction of [1; 0; 0] (i.e., along the x-axis), with an angle dispersion of pi / 8, average cluster separation of [20; 15; 25], average length of cluster-supporting lines of 16 (dispersion of 4 units), and lateral_disp of 3.5. The <code>seed</code> parameter is set to 123, demonstrating how to use the optional arguments.</p> <p>The following command plots the generated clusters:</p> <pre><code>scatter3(o.points(:, 1), o.points(:, 2), o.points(:,3), 36, o.clusters, 'filled', 'MarkerEdgeColor', 'k');\n</code></pre> <p></p>"},{"location":"reference/clupoints_n/","title":"clupoints_n","text":"<p>Generate points from their <code>n</code>-dimensional projections on a cluster-supporting line, placing each point around its projection using the normal distribution (\u03bc=0, \u03c3=<code>lat_disp</code>).</p> <pre><code>points = clupoints_n(projs, lat_disp, line_len, clu_dir, clu_ctr)\n</code></pre> <p>This function's main intended use is by the <code>clugen()</code> function, generating the final points when the <code>point_dist_fn</code> parameter is set to <code>\"n\"</code>.</p>"},{"location":"reference/clupoints_n/#arguments","title":"Arguments","text":"<ul> <li><code>projs</code>: Point projections on the cluster-supporting line.</li> <li><code>lat_disp</code>: Standard deviation for the normal distribution, i.e., cluster   lateral dispersion.</li> <li><code>line_len</code>: Length of cluster-supporting line (ignored).</li> <li><code>clu_dir</code>: Direction of the cluster-supporting line.</li> <li><code>clu_ctr</code>: Center position of the cluster-supporting line (ignored).</li> </ul>"},{"location":"reference/clupoints_n/#return-values","title":"Return values","text":"<ul> <li><code>points</code>: Generated points (\\(p \\times n\\) matrix).</li> </ul>"},{"location":"reference/clupoints_n/#note","title":"Note","text":"<p>This function is stochastic. For reproducibility set the PRNG seed with <code>cluseed()</code> as discussed in the Reference.</p>"},{"location":"reference/clupoints_n/#examples","title":"Examples","text":"<pre><code>cluseed(123);\nctr = [0; 0];\ndirec = [1; 0];\npdist = [-0.5; -0.2; 0.1; 0.3];\nproj = points_on_line(ctr, direc, pdist);\nclupoints_n(proj, 0.01, nan, direc, nan)\n% ans =\n%   -0.4980617   0.0061540\n%   -0.1906538  -0.0020521\n%    0.0852033   0.0163463\n%    0.3025630  -0.0110016\n</code></pre>"},{"location":"reference/clupoints_n_1/","title":"clupoints_n_1","text":"<p>Generate points from their n-dimensional projections on a cluster-supporting line, placing each point on a hyperplane orthogonal to that line and centered at the point's projection, using the normal distribution (\u03bc=0, \u03c3=<code>lat_disp</code>).</p> <pre><code>points = clupoints_n_1(projs, lat_disp, line_len, clu_dir, clu_ctr)\n</code></pre> <p>This function's main intended use is by the <code>clugen()</code> function, generating the final points when the <code>point_dist_fn</code> parameter is set to <code>\"n-1\"</code>.</p>"},{"location":"reference/clupoints_n_1/#arguments","title":"Arguments","text":"<ul> <li><code>projs</code>: Point projections on the cluster-supporting line (\\(p \\times n\\)   matrix).</li> <li><code>lat_disp</code>: Standard deviation for the normal distribution, i.e., cluster   lateral dispersion.</li> <li><code>line_len</code>: Length of cluster-supporting line (ignored).</li> <li><code>clu_dir</code>: Direction of the cluster-supporting line (unit vector).</li> <li><code>clu_ctr</code>: Center position of the cluster-supporting line (ignored).</li> </ul>"},{"location":"reference/clupoints_n_1/#return-values","title":"Return values","text":"<ul> <li><code>points</code>: Generated points (\\(p \\times n\\) matrix).</li> </ul>"},{"location":"reference/clupoints_n_1/#note","title":"Note","text":"<p>This function is stochastic. For reproducibility set the PRNG seed with <code>cluseed()</code> as discussed in the Reference.</p>"},{"location":"reference/clupoints_n_1/#examples","title":"Examples","text":"<pre><code>cluseed(123);\nctr = [0; 0];\ndirec = [1; 0];\npdist = [-0.5; -0.2; 0.1; 0.3];\nproj = points_on_line(ctr, direc, pdist);\nclupoints_n_1(proj, 0.1, nan, direc, nan)\n% ans =\n%\n%   -0.500000  -0.019383\n%   -0.200000  -0.093462\n%    0.100000  -0.147967\n%    0.300000  -0.025630\n</code></pre>"},{"location":"reference/clupoints_n_1_template/","title":"clupoints_n_1_template","text":"<p>Generate points from their \\(n\\)-dimensional projections on a cluster-supporting line, placing each point on a hyperplane orthogonal to that line and centered at the point's projection. The function specified in <code>dist_fn</code> is used to perform the actual placement.</p> <pre><code>points = clupoints_n_1_template(projs, lat_std, clu_dir, dist_fn)\n</code></pre> <p>This function is used internally by <code>clupoints_n_1()</code> and may be useful for constructing user-defined final point placement strategies for the <code>point_dist_fn</code> parameter of the main <code>clugen()</code> function.</p>"},{"location":"reference/clupoints_n_1_template/#arguments","title":"Arguments","text":"<ul> <li><code>projs</code>: Point projections on the cluster-supporting line (\\(p \\times n\\)   matrix).</li> <li><code>lat_disp</code>: Dispersion of points from their projection.</li> <li><code>clu_dir</code>: Direction of the cluster-supporting line (unit vector).</li> <li><code>dist_fn</code>: Function to place points on a second line, orthogonal to the   first.</li> </ul>"},{"location":"reference/clupoints_n_1_template/#return-values","title":"Return values","text":"<ul> <li><code>points</code>: Generated points (\\(p \\times n\\) matrix).</li> </ul>"},{"location":"reference/clupoints_n_1_template/#note","title":"Note","text":"<p>This function is stochastic. For reproducibility set the PRNG seed with <code>cluseed()</code> as discussed in the Reference.</p>"},{"location":"reference/clupoints_n_1_template/#examples","title":"Examples","text":"<pre><code>cluseed(123);\nctr = [0; 0];\ndirec = [1; 0];\npdist = [-0.5; -0.2; 0.1; 0.3];\nproj = points_on_line(ctr, direc, pdist);\nclupoints_n_1_template(proj, 10, direc, @(p, l) l * (rand(p, 1) - 0.5))\n% ans =\n%\n%   -0.50000  -4.47636\n%   -0.20000  -4.12813\n%    0.10000  -0.92758\n%    0.30000  -3.92300\n</code></pre>"},{"location":"reference/cluseed/","title":"cluseed","text":"<p>Initialize the random number generator with a given seed.</p> <pre><code> cluseed(seed)\n</code></pre>"},{"location":"reference/cluseed/#arguments","title":"Arguments","text":"<ul> <li><code>seed</code>: Seed for initializing the random number generator.</li> </ul>"},{"location":"reference/cluseed/#note","title":"Note","text":"<p>This function works in both MATLAB or Octave and simplifies reproducible executions of the different stochastic functions in this package. Note that reproducibility is only guaranteed within the same version of either MATLAB or Octave.</p>"},{"location":"reference/cluseed/#examples","title":"Examples","text":"<pre><code>% Set seed to 123\ncluseed(123);\n</code></pre>"},{"location":"reference/clusizes/","title":"clusizes","text":"<p>Determine cluster sizes, i.e., the number of points in each cluster, using the normal distribution (\u03bc=<code>num_points</code>/<code>num_clusters</code>, \u03c3=\u03bc/3), and then assuring that the final cluster sizes add up to <code>num_points</code> via the <code>fix_num_points()</code> function.</p> <pre><code> clu_num_points = clusizes(num_clusters, num_points, allow_empty)\n</code></pre>"},{"location":"reference/clusizes/#arguments","title":"Arguments","text":"<ul> <li><code>num_clusters</code>: Number of clusters.</li> <li><code>num_points</code>: Total number of points.</li> <li><code>allow_empty</code>: Allow empty clusters?</li> </ul>"},{"location":"reference/clusizes/#return-values","title":"Return values","text":"<ul> <li><code>clu_num_points</code>: Number of points in each cluster (<code>num_clusters</code> x 1 vector).</li> </ul>"},{"location":"reference/clusizes/#note","title":"Note","text":"<p>This function is stochastic. For reproducibility set the PRNG seed with <code>cluseed()</code> as discussed in the Reference.</p>"},{"location":"reference/clusizes/#examples","title":"Examples","text":"<pre><code>cluseed(123);\nsizes = clusizes(4, 1000, true)\n% sizes =\n%    268\n%    330\n%    128\n%    274\nsum(sizes)\n% ans = 1000\n</code></pre>"},{"location":"reference/fix_empty/","title":"fix_empty","text":"<p>Certify that, given enough points, no clusters are left empty.</p> <pre><code>num_points_fixed = fix_empty(clu_num_points, allow_empty)\n</code></pre> <p>This is done by removing a point from the largest cluster and adding it to an empty cluster while there are empty clusters. If the total number of points is smaller than the number of clusters (or if the <code>allow_empty</code> parameter is set to <code>true</code>), this function does nothing.</p> <p>This function is used internally by <code>clusizes()</code> and might be useful for custom cluster sizing implementations given as the <code>clusizes_fn</code> parameter of the main <code>clugen()</code> function.</p>"},{"location":"reference/fix_empty/#arguments","title":"Arguments","text":"<ul> <li><code>clu_num_points</code> - Number of points in each cluster (vector of size \\(c\\)),   where \\(c\\) is the number of clusters.</li> <li><code>allow_empty</code> - Allow empty clusters?</li> </ul>"},{"location":"reference/fix_empty/#return-values","title":"Return values","text":"<ul> <li><code>num_points_fixed</code> - Number of points in each cluster, after being fixed by   this function (vector of size \\(c\\)).</li> </ul>"},{"location":"reference/fix_empty/#examples","title":"Examples","text":"<pre><code>clusters = [3, 4, 5, 0, 0];\nfix_empty(clusters, false)\n% ans =\n%    3   3   4   1   1\n</code></pre>"},{"location":"reference/fix_num_points/","title":"fix_num_points","text":"<p>Certify that the values in the <code>clu_num_points</code> array, i.e. the number of points in each cluster, add up to <code>num_points</code>.</p> <pre><code>num_points_fixed = fix_num_points(clu_num_points, num_points)\n</code></pre> <p>If the values in the <code>clu_num_points</code> array, i.e. the number of points in each cluster, don't add up to <code>num_points</code>, this function increments the number of points in the smallest cluster while <code>sum(clu_num_points) &lt; num_points</code>, or decrements the largest cluster while <code>sum(clu_num_points) &gt; num_points</code>.</p> <p>This function is used internally by <code>clusizes()</code> and might be useful for custom cluster sizing implementations given as the <code>clusizes_fn</code> parameter of the main <code>clugen()</code> function.</p>"},{"location":"reference/fix_num_points/#arguments","title":"Arguments","text":"<ul> <li><code>clu_num_points</code> - Number of points in each cluster (vector of size \\(c\\)),   where \\(c\\) is the number of clusters.</li> <li><code>num_points</code> - The expected total number of points.</li> </ul>"},{"location":"reference/fix_num_points/#return-values","title":"Return values","text":"<ul> <li><code>num_points_fixed</code> - Number of points in each cluster, after being fixed by   this function (vector of size \\(c\\)).</li> </ul>"},{"location":"reference/fix_num_points/#examples","title":"Examples","text":"<pre><code>clusters = [1, 6, 3];\nfix_num_points(clusters, 12)\n% ans =\n%\n%    3   6   3\n</code></pre>"},{"location":"reference/is_octave/","title":"is_octave","text":"<p>Checks if the code is running in Octave or Matlab.</p> <pre><code>ioc = is_octave()\n</code></pre> <p>This function is used internally by <code>cluseed()</code>.</p>"},{"location":"reference/is_octave/#return-values","title":"Return values","text":"<ul> <li><code>ioc</code> - 5 if code is running in Octave, 0 otherwise.</li> </ul>"},{"location":"reference/llengths/","title":"llengths","text":"<p>Determine length of cluster-supporting lines using the folded normal distribution (\u03bc=<code>llength</code>, \u03c3=<code>llength_disp</code>).</p> <pre><code>lengths = llengths(num_clusters, llength, llength_disp)\n</code></pre>"},{"location":"reference/llengths/#arguments","title":"Arguments","text":"<ul> <li><code>num_clusters</code>: Number of clusters.</li> <li><code>llength</code>: Average line length.</li> <li><code>llength_disp</code>: Line length dispersion.</li> </ul>"},{"location":"reference/llengths/#return-values","title":"Return values","text":"<ul> <li><code>lengths</code>: Lengths of cluster-supporting lines (<code>num_clusters</code> x 1 vector).</li> </ul>"},{"location":"reference/llengths/#note","title":"Note","text":"<p>This function is stochastic. For reproducibility set the PRNG seed with <code>cluseed()</code> as discussed in the Reference.</p>"},{"location":"reference/llengths/#examples","title":"Examples","text":"<pre><code>cluseed(123);\nllengths(4, 20, 3.5)'\n% ans =\n%\n% 20.678   23.271   14.821   20.897\n</code></pre>"},{"location":"reference/points_on_line/","title":"points_on_line","text":"<p>Determine coordinates of points on a line with <code>center</code> and <code>direction</code>, based on the distances from the center given in <code>dist_center</code>.</p> <pre><code>points = points_on_line(center, direction, dist_center)\n</code></pre> <p>This works by using the vector formulation of the line equation assuming <code>direction</code> is a \\(n\\)-dimensional unit vector. In other words, considering \\(\\mathbf{d}=\\) <code>direction</code> (\\(n \\times 1\\)), \\(\\mathbf{c}=\\) <code>center</code> (\\(n \\times 1\\)), and \\(\\mathbf{w}=\\) <code>dist_center</code> (\\(p \\times 1\\)), the coordinates of points on the line are given by:</p> \\[ \\mathbf{P}=\\mathbf{1}\\,\\mathbf{c}^T + \\mathbf{w}\\mathbf{d}^T \\] <p>where \\(\\mathbf{P}\\) is the \\(p \\times n\\) matrix of point coordinates on the line, and \\(\\mathbf{1}\\) is a \\(p \\times 1\\) vector with all entries equal to 1.</p>"},{"location":"reference/points_on_line/#arguments","title":"Arguments","text":"<ul> <li><code>center</code> - Center of the line (\\(n \\times 1\\) vector).</li> <li><code>direction</code> - Line direction (\\(n \\times 1\\) unit vector).</li> <li><code>dist_center</code> - Distance of each point to the center of the line   (\\(p \\times 1\\) vector, where \\(p\\) is the number of points).</li> </ul>"},{"location":"reference/points_on_line/#return-values","title":"Return values","text":"<ul> <li><code>points</code> - Coordinates of points on the specified line (\\(p \\times n\\) matrix).</li> </ul>"},{"location":"reference/points_on_line/#examples","title":"Examples","text":"<pre><code>points_on_line([5; 5], [1; 0], (-4:2:4)') % 2D, 5 points\n% ans =\n%\n%    1   5\n%    3   5\n%    5   5\n%    7   5\n%    9   5\npoints_on_line([-2; 0; 0; 2], [0; 0; -1; 0], [10; -10]) % 4D, 2 points\n% ans =\n%\n%    -2    0  -10    2\n%    -2    0   10    2\n</code></pre>"},{"location":"reference/rand_ortho_vector/","title":"rand_ortho_vector","text":"<p>Get a random unit vector orthogonal to <code>u</code>.</p> <pre><code>v = rand_ortho_vector(u)\n</code></pre>"},{"location":"reference/rand_ortho_vector/#arguments","title":"Arguments","text":"<ul> <li><code>u</code> - A unit vector.</li> </ul>"},{"location":"reference/rand_ortho_vector/#return-values","title":"Return values","text":"<ul> <li><code>v</code> - A random unit vector orthogonal to <code>u</code>.</li> </ul>"},{"location":"reference/rand_ortho_vector/#note","title":"Note","text":"<p>This function is stochastic. For reproducibility set the PRNG seed with <code>cluseed()</code> as discussed in the Reference.</p>"},{"location":"reference/rand_ortho_vector/#examples","title":"Examples","text":"<pre><code>r = rand(3, 1);           % Get a random 3D vector\nr = r / norm(r);          % Normalize it\no = rand_ortho_vector(r); % Get a random unit vector orthogonal to r\ndot(r, o)    % Check that r and o are orthogonal (result should be ~0)\n% ans = 0\n</code></pre>"},{"location":"reference/rand_unit_vector/","title":"rand_unit_vector","text":"<p>Get a random unit vector with <code>num_dims</code> dimensions.</p> <pre><code>r = rand_unit_vector(num_dims)\n</code></pre>"},{"location":"reference/rand_unit_vector/#arguments","title":"Arguments","text":"<ul> <li><code>num_dims</code> - Number of dimensions.</li> </ul>"},{"location":"reference/rand_unit_vector/#return-values","title":"Return values","text":"<ul> <li><code>r</code> - A random unit vector with <code>num_dims</code> dimensions.</li> </ul>"},{"location":"reference/rand_unit_vector/#note","title":"Note","text":"<p>This function is stochastic. For reproducibility set the PRNG seed with <code>cluseed()</code> as discussed in the Reference.</p>"},{"location":"reference/rand_unit_vector/#examples","title":"Examples","text":"<pre><code>r = rand_unit_vector(4);\nnorm(r)\n% ans = 1\n</code></pre>"},{"location":"reference/rand_vector_at_angle/","title":"rand_vector_at_angle","text":"<p>Get a random unit vector which is at <code>angle</code> radians of vector <code>u</code>.</p> <pre><code>v = rand_vector_at_angle(u, angle)\n</code></pre>"},{"location":"reference/rand_vector_at_angle/#arguments","title":"Arguments","text":"<ul> <li><code>u</code> - A unit vector.</li> <li><code>angle</code> - An angle in radians.</li> </ul>"},{"location":"reference/rand_vector_at_angle/#return-values","title":"Return values","text":"<ul> <li><code>v</code> - A random unit vector which is at <code>angle</code> radians with vector <code>u</code></li> </ul>"},{"location":"reference/rand_vector_at_angle/#note","title":"Note","text":"<p>This function is stochastic. For reproducibility set the PRNG seed with <code>cluseed()</code> as discussed in the Reference.</p>"},{"location":"reference/rand_vector_at_angle/#examples","title":"Examples","text":"<pre><code>u = [1.0; 0; 0.5; -0.5];             % Define a 4D vector\nu = u / norm(u);                     % Normalize the vector\nv = rand_vector_at_angle(u, pi / 4); % Get a vector at 45 degrees\narad = acos(dot(u, v) / (norm(u) * norm(v))); % Get angle in radians\nrad2deg(arad) % Convert to degrees, should be close to 45 degrees\n% ans = 45.000\n</code></pre>"}]}